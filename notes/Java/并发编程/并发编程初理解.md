https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#%E8%AF%B7%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9


并发编程的三个重要特性

* 原子性：一次操作或者多次操作，要么所有的操作全部得到执行并且不会受到任何因素的干扰而中断，要么都不执行
* 可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值
* 有序性：

#### 线程

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的 **程序计数器** 、**虚拟机栈**和 **本地方法栈** ，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

![Java 运行时数据区域（JDK1.8 之后）](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png)

从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和 **方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器** 、**虚拟机栈** 和  **本地方法栈** 。

**总结：** **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**

##### 程序计数器为什么是私有的？

程序计数器主要有以下两个作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
2. 在多线程的情况下，程序计数器用于记录当前程序执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了

需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

所以，程序计数器私有主要是为了 **线程切换后能恢复到正确的执行位置** 。

##### 虚拟机栈和本地方法栈为什么是私有的？

* 虚拟机栈：每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
* 本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

所以，为了 **保证线程中的局部变量不被别的线程访问到** ，虚拟机栈和本地方法栈是线程私有的。

###### 一句话了解堆和方法区

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

##### Java 线程和操作系统的线程有啥区别？

JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。由于绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核），在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。

我们上面提到了用户线程和内核线程，考虑到很多读者不太了解二者的区别，这里简单介绍一下：

* 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）
* 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）

一句话概括 Java 线程和操作系统线程的关系： **现在的 Java 线程的本质其实就是操作系统的线程** 。

##### 如何创建线程

严格来说，Java 就只有一种方式可以创建线程，那就是通过 `new Thread().start()`创建。不管是哪种方式，最终还是依赖于 `new Thread().start()`

#### 线程的生命周期和状态

* NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
* RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。
* BLOCKED：阻塞状态，需要等待锁释放。
* WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
* TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
* TERMINATED：终止状态，表示该线程已经运行完毕。

  ![Java 线程状态变迁图](https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png)

由上图可以看出：线程创建之后它将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。

* 当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。
* **TIMED_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。
* 当线程进入 `synchronized` 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态。
* 线程在执行完了 `run()`方法之后将会进入到 **TERMINATED（终止）** 状态。

##### 什么是线程上下文切换

线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。

* 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
* 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
* 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
* 被终止或结束运行

这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的  **上下文切换** 。

上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。

##### Thread#sleep() 方法和 Object#wait() 方法对比

共同点：两者都可以暂停线程的执行
区别：

* sleep() 方法没有释放锁，而 wait() 方法释放了锁
* wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行
* wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成之后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。
* sleep() 是 Thread 类的静态本地方法，wait()则是 Object 类的本地方法

###### 为什么wait()方法不定义在 Thread 中？

wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（Object）都拥有对象锁，即然要释放当前线程占有的对象锁让其进入 WAITING 状态，自然是要操作对应的对象而非当前的线程

###### 为什么sleep()方法定义在 Thread 中？

因为 sleep（）是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁
